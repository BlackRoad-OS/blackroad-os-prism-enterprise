"""Prime counting reconstructions from Riemann zeta zeros.

This module implements light-weight helpers for experimenting with the
explicit formula relating the Chebyshev function :math:`\psi(x)` to the
non-trivial zeros of the Riemann zeta function.  It is intentionally
numerical rather than symbolic â€“ the goal is to provide convenient
building blocks for interactive demos such as the "prime-from-zeros"
synthesiser described in the research notes.

Only a finite list of zeros is required; by default we export the first
few ordinates so that experiments can begin without touching external
datasets.  The implementation assumes the usual symmetry of the zeros
and expects each conjugate pair to be represented by the zero with
non-negative imaginary part.
"""
from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, Sequence, Tuple
import math

__all__ = [
    "ZeroContribution",
    "PsiDecomposition",
    "chebyshev_psi",
    "synthesise_psi",
    "FIRST_ZETA_ZEROS",
]

# The first ten ordinates of non-trivial zeros on the critical line.
# Values are taken from tables in Titchmarsh (1986) and are sufficient
# for qualitative reconstructions of \(\psi(x)\) on modest ranges.
FIRST_ZETA_ZEROS: Tuple[complex, ...] = tuple(
    complex(0.5, t)
    for t in (
        14.134725141734693,
        21.022039638771555,
        25.010857580145688,
        30.424876125859513,
        32.935061587739190,
        37.586178158825671,
        40.918719012147495,
        43.327073280914999,
        48.005150881167160,
        49.773832477672302,
    )
)


@dataclass(frozen=True)
class ZeroContribution:
    """Snapshot of the oscillation generated by a single zero."""

    zero: complex
    amplitude: float
    frequency: float
    phase: float
    value: float

    def reconstruct(self, x: float) -> float:
        """Re-evaluate the oscillation for a new ``x``.

        The stored amplitude/phase correspond to the ``x`` used during the
        original construction.  Calling :meth:`reconstruct` simply
        re-computes the analytical form from scratch which is safer than
        rescaling the cached amplitude when the caller sweeps over a grid
        of ``x`` values.
        """

        sigma = self.zero.real
        abs_rho = abs(self.zero)
        if abs_rho == 0.0:
            raise ZeroDivisionError("zero cannot be at the origin")
        log_x = math.log(x)
        amplitude = 2.0 * (x ** sigma) / abs_rho
        phase = -math.atan2(self.zero.imag, self.zero.real)
        return amplitude * math.cos(self.zero.imag * log_x + phase)


@dataclass(frozen=True)
class PsiDecomposition:
    """Breakdown of the explicit formula for a single evaluation point."""

    x: float
    main_term: float
    zero_sum: float
    logarithmic_term: float
    trivial_term: float
    contributions: Tuple[ZeroContribution, ...]

    @property
    def value(self) -> float:
        """Return the reconstructed ``psi(x)`` value."""

        return self.main_term - self.zero_sum - self.logarithmic_term - self.trivial_term


def _validate_x(x: float) -> float:
    if x <= 1.0:
        raise ValueError("x must be greater than 1 for the explicit formula")
    return float(x)


def _validate_zeros(zeros: Sequence[complex]) -> Tuple[complex, ...]:
    prepared: list[complex] = []
    for zero in zeros:
        if zero.imag < -1e-12:
            raise ValueError("zeros should have non-negative imaginary part")
        if zero.imag < 0.0:
            # Treat tiny negative components as numerical noise.
            zero = complex(zero.real, 0.0)
        prepared.append(zero)
    return tuple(prepared)


def _zero_contribution(x: float, zero: complex) -> ZeroContribution:
    log_x = math.log(x)
    sigma = zero.real
    abs_rho = abs(zero)
    if abs_rho == 0.0:
        raise ZeroDivisionError("zero cannot be at the origin")

    amplitude = 2.0 * (x ** sigma) / abs_rho
    phase = -math.atan2(zero.imag, zero.real)
    value = amplitude * math.cos(zero.imag * log_x + phase)
    return ZeroContribution(zero=zero, amplitude=amplitude, frequency=zero.imag, phase=phase, value=value)


def _trivial_series(x: float, terms: int) -> float:
    if terms <= 0:
        return 0.0
    inverse_x_squared = x ** -2
    result = 0.0
    current = inverse_x_squared
    for n in range(1, terms + 1):
        result += current / (2 * n)
        current *= inverse_x_squared
    return result


def chebyshev_psi(
    x: float,
    zeros: Sequence[complex],
    *,
    correction_terms: int = 4,
) -> PsiDecomposition:
    """Approximate the Chebyshev ``psi`` function via Riemann's explicit formula.

    Parameters
    ----------
    x:
        Evaluation point (must be greater than ``1``).
    zeros:
        Iterable of non-trivial zeros.  It suffices to provide the zeros
        with non-negative imaginary parts; conjugates are automatically
        accounted for by symmetry.
    correction_terms:
        Number of terms retained from the tail ``\sum_{n \ge 1} x^{-2n}/(2n)``
        containing the contribution from the trivial zeros.
    """

    x = _validate_x(x)
    zeros = _validate_zeros(tuple(zeros))

    contributions = tuple(_zero_contribution(x, zero) for zero in zeros)
    zero_sum = sum(contribution.value for contribution in contributions)
    log_term = 0.5 * math.log(2 * math.pi)
    trivial_term = _trivial_series(x, correction_terms)
    return PsiDecomposition(
        x=x,
        main_term=x,
        zero_sum=zero_sum,
        logarithmic_term=log_term,
        trivial_term=trivial_term,
        contributions=contributions,
    )


def synthesise_psi(
    xs: Iterable[float],
    zeros: Sequence[complex],
    *,
    correction_terms: int = 4,
) -> Tuple[PsiDecomposition, ...]:
    """Evaluate :func:`chebyshev_psi` on multiple inputs."""

    return tuple(chebyshev_psi(x, zeros, correction_terms=correction_terms) for x in xs)
