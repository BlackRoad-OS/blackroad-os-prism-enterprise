name: auto-queue-ready

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]
  check_suite:
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  label-when-green:
    runs-on: ubuntu-latest
    steps:
      - name: Sync queue:ready label with required checks
        uses: actions/github-script@v7
        env:
          REQUIRED_CHECKS: build,test,lint,security,sbom,policy,eval
        with:
          script: |
            const required = (process.env.REQUIRED_CHECKS || '')
              .split(',')
              .map((name) => name.trim())
              .filter(Boolean);
            if (!required.length) {
              core.setFailed('REQUIRED_CHECKS cannot be empty.');
              return;
            }

            let prNumber = null;
            let headSha = null;

            if (context.eventName === 'pull_request') {
              prNumber = context.payload.pull_request?.number ?? null;
              headSha = context.payload.pull_request?.head?.sha ?? null;
            } else if (context.eventName === 'check_suite') {
              const suite = context.payload.check_suite;
              prNumber = suite?.pull_requests?.[0]?.number ?? null;
              headSha = suite?.head_sha ?? null;
            }

            if (!prNumber || !headSha) {
              core.info('No pull request head SHA to evaluate; skipping.');
              return;
            }

            const { data: prData } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            if (prData.draft) {
              core.info('PR is draft; ensure queue:ready label is removed.');
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: 'queue:ready',
                });
              } catch (error) {
                if (error.status !== 404) {
                  throw error;
                }
                core.info('queue:ready label not present; nothing to remove.');
              }
              return;
            }

            const checkRuns = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: prData.head.sha,
              status: 'completed',
              per_page: 100,
            });

            const successfulChecks = new Set();
            for (const check of checkRuns.data.check_runs) {
              if (check.conclusion === 'success') {
                successfulChecks.add(check.name);
              }
            }

            const combinedStatus = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: prData.head.sha,
            });

            for (const status of combinedStatus.data.statuses) {
              if (status.state === 'success') {
                successfulChecks.add(status.context);
              }
            }

            const missing = required.filter((name) => !successfulChecks.has(name));

            if (!missing.length) {
              core.info(`All required checks are green: ${required.join(', ')}`);
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['queue:ready'],
              });
            } else {
              core.info(`Missing checks: ${missing.join(', ')}`);
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: 'queue:ready',
                });
              } catch (error) {
                if (error.status !== 404) {
                  throw error;
                }
                core.info('queue:ready label not present; nothing to remove.');
              }
            }
