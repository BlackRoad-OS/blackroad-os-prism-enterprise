name: auto-queue-ready

on:
  workflow_run:
    workflows: ["build", "test", "lint", "security", "sbom", "policy", "eval"]
    types: [completed]

jobs:
  label-when-green:
    if: ${{ github.event.workflow_run.event == 'pull_request' && github.event.workflow_run.pull_requests }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      checks: read
    steps:
      - name: Synchronise queue label with required checks
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const required = ["build", "test", "lint", "security", "sbom", "policy", "eval"];
            const pull = context.payload.workflow_run.pull_requests?.[0];
            if (!pull) {
              core.info("No pull request associated with this workflow_run. Exiting.");
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const number = pull.number;
            const sha = context.payload.workflow_run.head_sha;

            const { data } = await github.rest.checks.listForRef({
              owner,
              repo,
              ref: sha,
              filter: "latest"
            });

            const successful = new Set(
              data.check_runs.filter(run => run.conclusion === "success").map(run => run.name)
            );

            const allGreen = required.every(name => successful.has(name));
            const label = "queue:ready";

            if (allGreen) {
              await github.rest.issues.addLabels({ owner, repo, issue_number: number, labels: [label] });
              core.info(`Applied ${label} to #${number}`);
            } else {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: number, name: label });
                core.info(`Removed ${label} from #${number}`);
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]
  check_suite:
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  label-when-green:
    runs-on: ubuntu-latest
    steps:
      - name: Sync queue:ready label with required checks
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        env:
          REQUIRED_CHECKS: build,test,lint,security,sbom,policy,eval
        with:
          script: |
            const required = (process.env.REQUIRED_CHECKS || '')
              .split(',')
              .map((name) => name.trim())
              .filter(Boolean);
            if (!required.length) {
              core.setFailed('REQUIRED_CHECKS cannot be empty.');
              return;
            }

            let prNumber = null;
            let headSha = null;

            if (context.eventName === 'pull_request') {
              prNumber = context.payload.pull_request?.number ?? null;
              headSha = context.payload.pull_request?.head?.sha ?? null;
            } else if (context.eventName === 'check_suite') {
              const suite = context.payload.check_suite;
              prNumber = suite?.pull_requests?.[0]?.number ?? null;
              headSha = suite?.head_sha ?? null;
            }

            if (!prNumber || !headSha) {
              core.info('No pull request head SHA to evaluate; skipping.');
              return;
            }

            const { data: prData } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            if (prData.draft) {
              core.info('PR is draft; ensure queue:ready label is removed.');
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: 'queue:ready',
                });
              } catch (error) {
                if (error.status !== 404) {
                  throw error;
                }
                core.info('queue:ready label not present; nothing to remove.');
              }
              return;
            }

            const checkRuns = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: prData.head.sha,
              status: 'completed',
              per_page: 100,
            });

            const successfulChecks = new Set();
            for (const check of checkRuns.data.check_runs) {
              if (check.conclusion === 'success') {
                successfulChecks.add(check.name);
              }
            }

            const combinedStatus = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: prData.head.sha,
            });

            for (const status of combinedStatus.data.statuses) {
              if (status.state === 'success') {
                successfulChecks.add(status.context);
              }
            }

            const missing = required.filter((name) => !successfulChecks.has(name));

            if (!missing.length) {
              core.info(`All required checks are green: ${required.join(', ')}`);
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['queue:ready'],
              });
            } else {
              core.info(`Missing checks: ${missing.join(', ')}`);
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: 'queue:ready',
                });
              } catch (error) {
                if (error.status !== 404) {
                  throw error;
                }
                core.info(`${label} was not present on #${number}`);
              }
            }

                core.info('queue:ready label not present; nothing to remove.');
              }
            }
